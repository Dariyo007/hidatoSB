<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hidato Puzzle</title>
<style>
body {
    font-family: Arial, sans-serif;
    text-align: center;
    background-color: #f4f4f4;
    margin: 0;
    padding: 20px;
}
h1 { color: #333; }
.grid {
    display: grid;
    grid-template-columns: repeat(5, 60px);
    gap: 5px;
    justify-content: center;
    margin-top: 20px;
}
.cell {
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    background-color: white;
    border: 1px solid #ccc;
    cursor: pointer;
}
.cell.fixed {
    background-color: #ddd;
    font-weight: bold;
    cursor: not-allowed;
}
.cell.selected {
    border: 2px solid #2196f3;
}
.controls {
    margin: 20px auto;
    display: flex;
    justify-content: center;
    gap: 10px;
}
button {
    padding: 8px 16px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
}
button.primary { background-color: #2196f3; color: white; }
button.secondary { background-color: #e0e0e0; color: #333; }
</style>
</head>
<body>
<h1>Hidato Puzzle</h1>
<p>Fill in the missing numbers to create a continuous chain. Click/tap to select, use arrow keys to move, and type numbers.</p>

<div class="grid" id="grid"></div>

<div class="controls">
    <button class="primary" onclick="checkPuzzle()">Check</button>
    <button class="secondary" onclick="giveHint()">Hint</button>
    <button class="secondary" onclick="clearCell()">Clear Cell</button>
    <button class="secondary" onclick="resetPuzzle()">Reset</button>
</div>

<script>
const size = 5;
let puzzle = [
    [1, 0, 0, 0, 0],
    [0, 0, 14, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 25]
];
let selected = { row: null, col: null };

function createGrid() {
    const grid = document.getElementById('grid');
    grid.innerHTML = '';
    puzzle.forEach((row, i) => {
        row.forEach((cell, j) => {
            const div = document.createElement('div');
            div.classList.add('cell');
            if (cell !== 0) {
                div.textContent = cell;
                div.classList.add('fixed');
            }
            div.addEventListener('click', () => selectCell(i, j));
            grid.appendChild(div);
        });
    });
}

function selectCell(row, col) {
    if (puzzle[row][col] !== 0) return;
    const cells = document.querySelectorAll('.cell');
    cells.forEach(c => c.classList.remove('selected'));
    selected = { row, col };
    const index = row * size + col;
    cells[index].classList.add('selected');
}

function handleKey(e) {
    if (selected.row === null) return;
    let { row, col } = selected;
    if (e.key >= '0' && e.key <= '9') {
        let value = parseInt(e.key);
        if (value !== 0) updateCell(row, col, value);
    } else if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
        e.preventDefault();
        if (e.key === 'ArrowUp' && row > 0) row--;
        if (e.key === 'ArrowDown' && row < size - 1) row++;
        if (e.key === 'ArrowLeft' && col > 0) col--;
        if (e.key === 'ArrowRight' && col < size - 1) col++;
        selectCell(row, col);
    }
}

function updateCell(row, col, value) {
    puzzle[row][col] = value;
    createGrid();
    selectCell(row, col);
}

function clearCell() {
    if (selected.row !== null) {
        puzzle[selected.row][selected.col] = 0;
        createGrid();
    }
}

function checkPuzzle() {
    alert('Check feature to be implemented.');
}

function giveHint() {
    alert('Hint feature to be implemented.');
}

function resetPuzzle() {
    puzzle = [
        [1, 0, 0, 0, 0],
        [0, 0, 14, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 25]
    ];
    createGrid();
}

document.addEventListener('keydown', handleKey);
createGrid();
</script>
</body>
</html>
